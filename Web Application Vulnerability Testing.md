### Web Application Vulnerability Testing: Detailed Notes and Step-by-Step Guide

#### **Introduction**
Testing a web application for vulnerabilities is a structured process designed to identify security flaws. This is typically done through a combination of manual and automated techniques. Below is a detailed step-by-step guide to performing a comprehensive vulnerability assessment and penetration testing (VAPT) on a web application.

---

### **1. Preparation and Reconnaissance**
#### **Step 1.1: Define the Scope**
- Identify the target web application, subdomains, and assets.
- Obtain proper permissions from the owner of the web application to perform testing (if not owned by you).
- Define the testing boundaries, e.g., APIs, databases, backend servers.

#### **Step 1.2: Information Gathering**
- Use **passive reconnaissance** (no interaction with the target):
  - Tools: Whois, DNS recon, Google Dorking.
- Use **active reconnaissance** (interact with the target):
  - Tools: Nmap (port scanning), Shodan (IoT or server information).
  - Techniques: Extract HTTP headers, check for exposed API keys.

#### **Step 1.3: Technology Stack Fingerprinting**
- Identify server software, frameworks, and CMS.
  - Tools: Wappalyzer, BuiltWith, WhatWeb.

---

### **2. Vulnerability Identification**
#### **Step 2.1: Automated Vulnerability Scanning**
- Use automated tools to scan for vulnerabilities such as SQL injection, XSS, etc.:
  - Tools: OWASP ZAP, Burp Suite, Nessus, Nikto.
- Review scan reports for potential vulnerabilities.

#### **Step 2.2: Manual Testing**
- Look for hidden endpoints, sensitive data leaks in URLs, and insecure configurations.
- Use browser developer tools for debugging and testing.

#### **Step 2.3: Static and Dynamic Code Analysis**
- **Static Application Security Testing (SAST)**: Analyze source code (if available) for security flaws.
- **Dynamic Application Security Testing (DAST)**: Test the application in its running state.

---

### **3. Exploit Known Vulnerabilities**
#### **Step 3.1: Testing for OWASP Top 10 Vulnerabilities**
Follow the **OWASP Top 10 Vulnerabilities** as a framework:
---
1. **Injection Attacks**
   - Test for SQL Injection, Command Injection.
   - Tools: SQLmap, Burp Suite Intruder.
   - Example: Enter `' OR '1'='1` in input fields and observe the response.

### **Where to Find SQL Injection and Command Injection Vulnerabilities:**

Both **SQL Injection** and **Command Injection** vulnerabilities are commonly found in web applications and systems that improperly handle user input. Below is a detailed list of areas and components where these vulnerabilities are most often found:

---

### **SQL Injection:**

**1. User Login Forms:**
   - **Where**: Login pages or authentication systems where users provide credentials (e.g., username and password).
   - **Why**: If user inputs are directly incorporated into SQL queries without validation or parameterization, SQL injection becomes possible.
   - **Test Example**: Enter `' OR '1'='1` into the username or password field and observe if login bypasses.

**2. Search Forms:**
   - **Where**: Any form or input field that takes search terms from the user.
   - **Why**: If the search query is used directly in a SQL query (e.g., `SELECT * FROM products WHERE name = 'search_term'`), it is vulnerable to SQL injection.
   - **Test Example**: Try entering a payload like `' OR '1'='1 --` in the search field to see if the application returns extra data.

**3. URL Query Parameters:**
   - **Where**: URLs that pass user input as query parameters (e.g., `http://example.com/product?id=5`).
   - **Why**: These parameters are often directly included in SQL queries.
   - **Test Example**: Modify the query string by adding `OR 1=1 --` to the `id` parameter and observe the application's response.

**4. Contact Forms (with email, name, message fields):**
   - **Where**: Forms that accept unvalidated user input (e.g., message submission or customer feedback forms).
   - **Why**: If the form inputs are used directly in database queries without proper sanitization, they can be exploited.
   - **Test Example**: Inject SQL syntax like `' OR '1'='1` into the fields.

**5. Profile Update or Account Settings Pages:**
   - **Where**: User profile forms, account settings, and any form that allows the modification of stored data (e.g., username, email, password).
   - **Why**: If user inputs are included in SQL queries that update records, these forms may be vulnerable to SQL injection.
   - **Test Example**: Try injecting SQL code into input fields such as `username` or `email`.

**6. URL Path Parameters:**
   - **Where**: Any URL that takes a parameter from the path rather than the query string (e.g., `http://example.com/article/123`).
   - **Why**: This type of input is often incorporated directly into a SQL query for fetching records.
   - **Test Example**: Modify the path parameter to inject SQL commands like `/article/123' OR 1=1`.

**7. File Uploads (with metadata or file name input):**
   - **Where**: Web applications that allow file uploads may include the file name or other metadata in database queries.
   - **Why**: If the file name or metadata is used in SQL queries without sanitization, it could lead to SQL injection.
   - **Test Example**: Upload a file with an SQL-injection payload as the filename (e.g., `evil' OR 1=1 --.jpg`).

---

### **Command Injection:**

**1. User Input Fields that Interact with the Operating System:**
   - **Where**: Forms that accept input used by backend scripts or applications that interact with the operating system (e.g., file upload forms, search fields).
   - **Why**: If user input is passed directly into a system shell command (e.g., `system('ls -l')`), attackers can inject commands that the system will execute.
   - **Test Example**: Enter `; ls` or `| whoami` into a search or input field to test if system commands are executed.

**2. URL Parameters that Trigger System Commands:**
   - **Where**: URLs that pass user input to system commands (e.g., `http://example.com/search?cmd=ls`).
   - **Why**: If a command is constructed using input from the URL, attackers can inject shell commands.
   - **Test Example**: Modify a parameter like `cmd=; ls` or `cmd=| id` to see if the application executes the command.

**3. Forms that Accept System Command Parameters:**
   - **Where**: Any form that takes user input and processes it using system commands (e.g., form submission to execute a script).
   - **Why**: If the form data is used to construct shell commands, an attacker can inject commands.
   - **Test Example**: Try injecting `; whoami` or `| cat /etc/passwd` into form fields.

**4. Search and Query Parameters that Call OS Processes:**
   - **Where**: Search fields or queries that are later passed to operating system-level processes.
   - **Why**: If the input is used in a command execution context (e.g., invoking a search through system commands), it can be exploited.
   - **Test Example**: Test with `; ls` to see if the application executes the command and returns system information.

**5. File Upload or File Path Inputs:**
   - **Where**: File upload forms or file path inputs that are passed to backend scripts.
   - **Why**: File paths or file names passed to system commands may lead to command injection if they are not properly validated or sanitized.
   - **Test Example**: Try inputting `; ls` as a filename or path parameter to test for command execution.

**6. Admin Interfaces or System Administration Pages:**
   - **Where**: Admin or backend interfaces that allow for system administration actions (e.g., restarting services, viewing logs, or managing configurations).
   - **Why**: These pages may involve running OS commands for system tasks, making them potential targets for command injection.
   - **Test Example**: Inject commands like `; cat /etc/passwd` or `; id` in fields that control system actions.

**7. HTTP Headers (e.g., `User-Agent`, `X-Forwarded-For`):**
   - **Where**: Some web applications may pass headers directly into system commands or scripts that execute system-level tasks.
   - **Why**: HTTP headers are sometimes used for log generation or filtering, which can be vulnerable to command injection.
   - **Test Example**: Test headers like `User-Agent: Mozilla/5.0; ls` to see if any command is executed.

---

### **Conclusion:**

Both **SQL Injection** and **Command Injection** can occur in many areas where user input interacts with the system or database. **SQL Injection** typically affects areas where user data is used in SQL queries without proper sanitization, while **Command Injection** is more concerned with user input being passed directly to system shell commands.

**Key Areas to Focus on**:
- **Forms** (login, search, profile update, contact forms).
- **URL Parameters** (query parameters, path parameters).
- **File Uploads** (filename or metadata).
- **HTTP Headers** (like `User-Agent` or `X-Forwarded-For`).
- **Admin Panels** that execute OS commands.

---

2. **Broken Authentication**
   - Check for weak login mechanisms.
   - Test brute force attacks on login pages.
   - Tools: Hydra, Burp Suite, OWASP ZAP.

3. **Sensitive Data Exposure**
   - Check if sensitive information is sent over plain HTTP.
   - Analyze cookies and headers for secure flags.
   - Tools: Wireshark, OWASP ZAP.

4. **XML External Entity (XXE) Attacks**
   - Test XML parsers for vulnerabilities.
   - Example: Inject malicious XML payloads to access restricted files.

5. **Broken Access Control**
   - Check unauthorized access to admin panels, APIs, etc.
   - Tools: Manual testing, Burp Suite.

6. **Security Misconfigurations**
   - Look for default configurations, exposed directories.
   - Tools: Nikto, Nessus.

7. **Cross-Site Scripting (XSS)**
   - Test input fields with payloads like `<script>alert('XSS')</script>`.
   - Tools: Burp Suite, OWASP ZAP.

8. **Insecure Deserialization**
   - Test serialization mechanisms for arbitrary code execution.

9. **Using Components with Known Vulnerabilities**
   - Check software versions and compare with CVE databases.
   - Tools: Dependency-Check, Retire.js.

10. **Insufficient Logging and Monitoring**
   - Simulate an attack and check logs to assess visibility.

#### **Step 3.2: Test Business Logic Flaws**
- Identify how the application handles workflows (e.g., bypassing payment mechanisms).
- Perform fuzz testing to input unexpected data.

---

### **4. Advanced Attack Techniques**
#### **Step 4.1: Server-Side Request Forgery (SSRF)**
- Test endpoints that allow making HTTP requests on behalf of the server.
- Tools: Burp Collaborator.

#### **Step 4.2: Cross-Site Request Forgery (CSRF)**
- Test if actions can be performed on behalf of authenticated users without their consent.

#### **Step 4.3: API Security Testing**
- Inspect API endpoints for:
  - Rate limiting issues.
  - Improper authentication.
- Tools: Postman, Burp Suite.

#### **Step 4.4: Subdomain Takeover**
- Identify unclaimed subdomains pointing to external services.
- Tools: Sublist3r, Amass.

#### **Step 4.5: Cloud Security Testing**
- Check for misconfigured AWS S3 buckets or exposed credentials.

---

### **5. Post-Exploitation and Reporting**
#### **Step 5.1: Risk Assessment**
- Rate vulnerabilities based on their severity using CVSS (Common Vulnerability Scoring System).

#### **Step 5.2: Documentation**
- Include the following in the report:
  - Executive summary.
  - Vulnerability details and reproduction steps.
  - Mitigation recommendations.

#### **Step 5.3: Clean-Up**
- Remove any payloads or test data injected during the process.
- Ensure no disruptions to the application after testing.

---

### **Preferred Order of Attacks**
1. Reconnaissance (Passive and Active)
2. Automated Scanning
3. Manual Testing of OWASP Top 10
4. API and Business Logic Flaws
5. Advanced Attacks (e.g., SSRF, Subdomain Takeover)
6. Post-Exploitation (e.g., logging, reporting)

---

### Detailed Notes: Web Application Vulnerability Testing Using **Burp Suite Pro**

Burp Suite Pro is a powerful web vulnerability scanner and penetration testing tool. This guide provides step-by-step notes focusing on using Burp Suite Pro for testing vulnerabilities in a web application.

---

## **1. Preparation and Reconnaissance**

### **1.1 Define the Scope**
1. **Clarify Goals:**
   - Determine testing objectives: compliance, security assessment, or penetration testing.
   - Specify in-scope targets: domains, subdomains, APIs.
   
2. **Get Permissions:**
   - Ensure you have written authorization to test.

3. **Set Up Burp Suite:**
   - Install the **Burp CA Certificate** in your browser for HTTPS interception.
   - Configure your browser to route traffic through Burp's proxy (default: `127.0.0.1:8080`).

---

### **1.2 Information Gathering**

#### **Passive Reconnaissance**
- Use **Target Tab** in Burp to:
  - Identify endpoints and directories (auto-populated during browsing).
  - Review the Site Map for server structure.
  
- External tools to supplement:
  - **DNS Enumeration**: Use tools like Nslookup, or external services like MXToolbox.
  - **Google Dorking**: Search for sensitive information.

#### **Active Reconnaissance**
1. **Crawl Application:**
   - Use Burp's **Spider** feature to discover all URLs and parameters.
   
2. **Identify Technologies:**
   - Use the **HTTP History** tab to review server responses (headers, cookies, frameworks).

---

## **2. Vulnerability Identification**

### **2.1 Automated Scanning**
- Go to the **Dashboard Tab**:
  - Start **Active Scan** on identified endpoints.
  - Burp Suite Pro will look for vulnerabilities like SQLi, XSS, CSRF.
  
- Customize scans:
  - Use scan configurations to focus on specific vulnerabilities.
  - Example: Select **SQL Injection Module** if testing databases.

---

### **2.2 Manual Testing**
#### Using **Repeater**:
- Send requests to **Repeater** for manual tampering.
- Modify inputs to test parameters for:
  - Injection vulnerabilities.
  - Business logic flaws.

#### Using **Intruder**:
- Launch targeted brute force or fuzzing attacks:
  - Configure positions (marked by `§`).
  - Use payloads (predefined or custom) for injection testing.

---

### **2.3 Static and Dynamic Analysis**
#### Dynamic Analysis (DAST):
- Test the live application for vulnerabilities.
- Example:
  - Test input validation by intercepting form submissions in the Proxy tab.

#### Static Analysis (Optional if source code is available):
- Combine with external tools for SAST to find insecure coding patterns.

---

## **3. Exploitation of Vulnerabilities**

### **3.1 Injection Attacks**
- Use Burp's **Scanner** or **Intruder** to test for:
  - SQL Injection:
    - Enter `' OR '1'='1` or similar payloads in inputs.
    - Check for errors or abnormal behavior.
    - Tools: Integrate SQLmap with Burp via plugins.
  - Command Injection:
    - Inject commands like `; ls` to verify execution.
  
---

### **3.2 Cross-Site Scripting (XSS)**
- Use the **Scanner** or manually inject payloads:
  - Example: `<script>alert('XSS')</script>`.
- Analyze browser behavior for reflected or stored XSS.

---

### **3.3 Broken Access Control**
- Check:
  - Direct Object References (IDOR) by modifying query parameters.
  - Unauthorized access to admin pages.

---

### **3.4 Security Misconfigurations**
- Use Burp to analyze HTTP headers:
  - Verify secure headers like `X-Content-Type-Options` and `Content-Security-Policy`.
- Use **Scanner** to identify open directories or default credentials.

---

### **3.5 API Security Testing**
- Use Burp to interact with APIs:
  - Modify request bodies or headers for attacks like mass assignment.
  - Test rate-limiting by using **Intruder**.

---

### **3.6 Advanced Techniques**
#### Server-Side Request Forgery (SSRF):
- Use Burp Collaborator to send callbacks to internal servers.
- Monitor for requests triggered by malicious input.

#### Cross-Site Request Forgery (CSRF):
- Analyze hidden tokens and headers.
- Use Burp’s **CSRF PoC Generator** to craft malicious forms.

---

## **4. Post-Exploitation**

### **4.1 Risk Assessment**
- Rate vulnerabilities using CVSS (Critical, High, Medium, Low).
- Use Burp's detailed issue descriptions to evaluate impact.

---

### **4.2 Reporting**
- Use Burp’s **Report Generator**:
  - Customize reports to include vulnerability details, reproduction steps, and fixes.
  - Export in formats like HTML or XML for stakeholders.

---

### **4.3 Clean-Up**
- Reset any modified credentials.
- Inform stakeholders of any potential residual impacts.

---

## **Preferred Workflow in Burp Suite Pro**
1. **Set Up Proxy and Browser Integration**.
2. **Use Spider to map the application**.
3. **Automated Scanning with Custom Configurations**.
4. **Targeted Manual Testing with Intruder and Repeater**.
5. **Analyze Results in Dashboard and Generate Reports**.

This guide is optimized for using **Burp Suite Pro** to its fullest potential. 
